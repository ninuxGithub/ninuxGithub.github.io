---
title: Hystrix使用 
author: ninuxGithub
layout: post
date: 2019-1-3 10:39:37
description: "Hystrix使用 "
tag: java
---


## Hystrix的个人理解

    Spring cloud 提供的Hystrix为服务的延时超时， 网络延迟导致的服务的请求提供了一个容错的解决方案， 在集群里面服务相互调用的时候，
    不会因为一个节点的调用失败而影响到其他服务的业务调用， hystrix 的熔断机制为解决降级，服务熔断，线程和信号隔离，请求缓存，请求合并
    以及服务监控提供强大的功能。
    
    
    
## hystrix 熔断的使用
    pom配置
      
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>
</dependencies>
```      

    yml配置如下：

```yaml
server:
  port: 8763 #修改启动服务在不同的端口  8762,8763 两个端口
spring:
  application:
    name: eurka-client
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
management:
  endpoints:
    web:
      exposure:
        include: '*'
      cors:
        allowed-origins: '*'
        allowed-methods: '*'

```


   java代码如下：


```java

//----------------------服务提供的接口


package com.example.demo;

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.TimeUnit;

@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
@RestController
@EnableHystrix
@EnableHystrixDashboard
@EnableCircuitBreaker
public class EurekaClientApplication {

    /**
     * 访问地址 http://localhost:8762/actuator/hystrix.stream
     *
     * @param args
     */

    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }


    @Value("${server.port}")
    String port;

    @RequestMapping("/hi")
    @HystrixCommand(fallbackMethod = "hiError")
    public String home(@RequestParam(value = "name", defaultValue = "ninuxGithub") String name) {
        try {
            
            if (port==8763){  //8763 端口的服务睡眠  8762 的补睡眠
                
                TimeUnit.SECONDS.sleep(3);
                //加入3秒的睡眠， hystrix 因为调用客户端的api超时而产生短路---
                //从而调用hiError 方法
            }
            
            
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "hi " + name +  " i am from port: " + port;
    }

    public String hiError(String name) {
        return "hi," + name + ",sorry,error!";
    }
    

}


```

    ribbon服务端java代码参考：https://ninuxgithub.github.io/2018/12/scpost4/
    这个博客配置的是权重的负载均衡的策略
    当发现一个请求的消耗的时间长的时候会调整权重  
    
    
    
    所以在8762  端口的权重会加重  8763因为短路器的调用  发现服务调用延时而权重降低
    请求到8763端口的服务会由于超时而导致服务不可以走  处理熔断的方法  （可以理解为一种补偿的方法）
    
    


## hystrix开启异步调用

    client服务端
    
```java
@RequestMapping("/getMessage")
public Message asyncRequest() {
    return new Message(Integer.valueOf(port), "这是一个异步调用的方式,来自 " + port);
}
    



//ribbon 服务端
 //异步方法的调用
 
 
    @HystrixCommand(fallbackMethod = "getMessageError")
    public Future<Message> getMessage() {
        return new AsyncResult<Message>() {
            @Override
            public Message invoke() {
                System.out.println(10/0);;
                return restTemplate.getForObject("http://EURKA-CLIENT/getMessage", Message.class);
            }
        };
    }

    //异常的处理
    public Message getMessageError(Throwable throwable) {
        return new Message(1, "default message"+ throwable.getMessage());
    }




```    
   
    
    


    
    
    
         
      

        
    